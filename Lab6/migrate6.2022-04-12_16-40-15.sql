/*SET DEFINE OFF;
PROMPT Creating User Emulation ...
CREATE USER Emulation IDENTIFIED BY Emulation DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW,  CREATE SYNONYM,CREATE PUBLIC SYNONYM  TO Emulation;
SET SCAN OFF;
PROMPT Creating User dbo_PERSONNEL ...
CREATE USER dbo_PERSONNEL IDENTIFIED BY dbo_PERSONNEL DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM TO dbo_PERSONNEL;
connect Emulation/Emulation;

create or replace
PACKAGE UTILS AS
SQLSERVER           VARCHAR2(10)  := 'SQLSERVER';
SYBASE              VARCHAR2(10)  := 'SYBASE';
DATABASE_TYPE       VARCHAR2(10)  := SQLSERVER;

IDENTITY   NUMBER(10);
TRANCOUNT  NUMBER(10):=0;
VAR_NUMBER NUMBER(10):=0;

FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2;
FUNCTION BIGINTTOHEX(P_EXPR RAW)    RETURN VARCHAR2;

FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;

FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER;

FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;

FUNCTION BIT_COMPLIMENT(P_RAW1 RAW )    RETURN RAW;
FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER;

FUNCTION CONVERT_TO_BLOB    (P_EXPR IN VARCHAR2                 ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;
FUNCTION CONVERT_TO_BLOB    (P_EXPR IN NUMBER                   ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TIMESTAMP	              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;

FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN VARCHAR2	                 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN DATE	                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TIMESTAMP	               , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TIMESTAMP WITH TIME ZONE	 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP;

FUNCTION CONVERT_TO_TIMESTAMP_TZ	  (P_EXPR IN VARCHAR2	                 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE;
FUNCTION CONVERT_TO_TIMESTAMP_TZ	  (P_EXPR IN DATE	                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE;
FUNCTION CONVERT_TO_TIMESTAMP_TZ	  (P_EXPR IN TIMESTAMP	               , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE;
FUNCTION CONVERT_TO_TIMESTAMP_TZ	  (P_EXPR IN TIMESTAMP WITH TIME ZONE	 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
FUNCTION CONVERT_TO_NUMBER  (P_BLOB_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;
FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;
FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN FLOAT  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2  (P_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0)    RETURN VARCHAR2;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                    , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;

FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TIMESTAMP)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TIMESTAMP WITH TIME ZONE)  RETURN VARCHAR2;

FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TIMESTAMP)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_STR IN VARCHAR2) RETURN TIMESTAMP;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN DATE) RETURN DATE;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TIMESTAMP) RETURN TIMESTAMP;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN TIMESTAMP WITH TIME ZONE;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;

FUNCTION YEAR_(P_DATE_STR    IN VARCHAR2) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN DATE) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN TIMESTAMP) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION MONTH_(P_DATE_STR  IN VARCHAR2) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN DATE) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN TIMESTAMP) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION DAY_(P_DATE_STR    IN VARCHAR2) RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN DATE) RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN TIMESTAMP) RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER;

FUNCTION STUFF(P_EXPR VARCHAR2, P_STARTIDX NUMBER, P_LEN NUMBER, P_REPLACE_EXPR VARCHAR2)  RETURN VARCHAR2;
FUNCTION REVERSE_(P_EXPR IN VARCHAR2)                                                      RETURN VARCHAR2;
FUNCTION QUOTENAME(P_STR IN VARCHAR2, P_DELIMITERS IN VARCHAR2 DEFAULT '[]')               RETURN VARCHAR2;
FUNCTION PARSENAME(P_OBJECT_NAME IN VARCHAR2, P_OBJECT_PIECE IN NUMBER)                    RETURN VARCHAR2;
FUNCTION DIFFERENCE(P_EXPR1 IN VARCHAR2, P_EXPR2 IN VARCHAR2)                              RETURN NUMBER;
FUNCTION PATINDEX(P_PATTERN IN VARCHAR2, P_EXPR IN VARCHAR2, P_FORMAT IN VARCHAR2 DEFAULT 'USING CHARS') RETURN NUMBER;
 
--NOTE THESE ALL NEED TO BE OVERRIDDEN WITH TIMESTAMP,TIMESTAMP TZ AND DATE DATA TYPES . LETS TEST REST FIRST
FUNCTION STATS_DATE(P_TABLE IN VARCHAR2,  P_INDEX IN VARCHAR2) RETURN DATE;

FUNCTION ISDATE(P_EXPR      IN VARCHAR2) RETURN NUMBER;
FUNCTION ISNUMERIC(P_EXPR IN VARCHAR2)       RETURN NUMBER;
FUNCTION DEGREES(P_ANGLE_RADIANS IN NUMBER)  RETURN NUMBER;
FUNCTION RADIANS(P_DEGREE IN NUMBER)         RETURN NUMBER;
FUNCTION ROUND_(P_EXPR NUMBER, P_LEN NUMBER, P_FUNCTION NUMBER DEFAULT 0)  RETURN NUMBER;
FUNCTION RAND(P_SEED NUMBER DEFAULT NULL)    RETURN NUMBER;
FUNCTION OCT(P_NUM VARCHAR2)                 RETURN VARCHAR2;
FUNCTION HEX(P_NUM VARCHAR2)                 RETURN VARCHAR2;
FUNCTION TO_BASE(P_DEC NUMBER, P_BASE NUMBER)RETURN VARCHAR2;

FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2;
FUNCTION PI RETURN NUMBER;

PROCEDURE COMMIT_TRANSACTION;
PROCEDURE RESETTRANCOUNT;
PROCEDURE DECREMENTTRANCOUNT;
PROCEDURE INCREMENTTRANCOUNT;
FUNCTION GETIDENTITY RETURN NUMBER;
FUNCTION IDENT_INCR(P_SEQUENCE IN VARCHAR2)     RETURN NUMBER;
FUNCTION FETCH_STATUS(P_CURSORFOUND IN BOOLEAN) RETURN NUMBER;
FUNCTION SQLSTATUS(P_CURSORFOUND IN BOOLEAN,P_CURSOROPEN IN BOOLEAN) RETURN NUMBER;
FUNCTION IDENT_SEED(P_SEQUENCE IN VARCHAR2) RETURN NUMBER;

PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2);

END UTILS;
/

create or replace
PACKAGE BODY UTILS AS

TYPE VARCHAR2_ARRAY IS TABLE OF VARCHAR2(100);
DT_FORMATS          VARCHAR2_ARRAY; -- Customer : Please Modify the List of Date/Timestamp Formats so that the most common T-SQL literals are at the top
DT_DAY              VARCHAR2_ARRAY; -- Datetime formats starting with Day
DT_MONTH            VARCHAR2_ARRAY; -- Datetime formats starting with Month
DT_YEAR             VARCHAR2_ARRAY; -- Datetime formats starting with Year
DT_TIME             VARCHAR2_ARRAY; -- Datetime formats just having Hour, Minute, Second and Fractional seconds
DT_NLS              VARCHAR2_ARRAY; -- Oracle NLS DateTime formats

    
DEFAULT_CHAR_SIZE NUMBER := 30;    

-- PRIVATE 
FUNCTION GET_FORMAT_FROM_STYLE(P_STYLE NUMBER) RETURN VARCHAR2
IS
V_FORMAT VARCHAR2(50);
BEGIN
IF DATABASE_TYPE = SYBASE THEN --http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.blocks/html/blocks/blocks125.htm
V_FORMAT := CASE 

                WHEN P_STYLE = 0   THEN  'Mon DD YYYY HH12:MI AM'
                WHEN P_STYLE = 100 THEN  'Mon DD YYYY HH12:MI AM'
                WHEN P_STYLE = 1   THEN  'MM/DD/YY'
                WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
                WHEN P_STYLE = 2   THEN  'YY.MM.DD'
                WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
                WHEN P_STYLE = 3   THEN  'DD/MM/YY'
                WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
                WHEN P_STYLE = 4   THEN  'DD.MM.YY'
                WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
                WHEN P_STYLE = 5   THEN  'DD-MM-YY'
                WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
                WHEN P_STYLE = 6   THEN  'DD Mon YY'
                WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
                WHEN P_STYLE = 7   THEN  'Mon DD, YY'
                WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
                WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
                WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
                WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 10  THEN  'MM-DD-YY'
                WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
                WHEN P_STYLE = 11  THEN  'YY/MM/DD'
                WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
                WHEN P_STYLE = 12  THEN  'YYMMDD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 112 THEN  'YYYYMMDD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 13  THEN  'YY/DD/MM' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 113 THEN  'YYYY/DD/MM'
                WHEN P_STYLE = 14  THEN  'MM/YY/DD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 114 THEN  'MM/YYYY/DD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 15  THEN  'DD/YY/MM'
                WHEN P_STYLE = 115 THEN  'DD/YYYY/MM'
                WHEN P_STYLE = 16  THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
                WHEN P_STYLE = 116 THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
                WHEN P_STYLE = 17  THEN  'FMHH12:MIAM'
                WHEN P_STYLE = 117 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 18  THEN  'HH24:MI'
                WHEN P_STYLE = 118 THEN  'YYYY/MM/DD FMHH12:MIAM' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 19  THEN  'FMHH12:MI:SS:FF3AM'
                WHEN P_STYLE = 119 THEN  'FMHH12:MI:SS:FF3AM'        
                WHEN P_STYLE = 20  THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 120 THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 21  THEN  'YY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 121 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 22  THEN  'YY/MM/DD  fmHH:MIAM'
                WHEN P_STYLE = 122 THEN  'YYYY/MM/DD  fmHH:MIAM'
                WHEN P_STYLE = 23  THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 123 THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                END;
END IF;
IF DATABASE_TYPE = SQLSERVER THEN
V_FORMAT := CASE 
                WHEN P_STYLE = 0   THEN  'MON DD YYYY HH12:MIAM'
                WHEN P_STYLE = 100 THEN  'MON DD YYYY HH12:MIAM'
                WHEN P_STYLE = 1   THEN  'MM/DD/YY'
                WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
                WHEN P_STYLE = 2   THEN  'YY.MM.DD'
                WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
                WHEN P_STYLE = 3   THEN  'DD/MM/YY'
                WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
                WHEN P_STYLE = 4   THEN  'DD.MM.YY'
                WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
                WHEN P_STYLE = 5   THEN  'DD-MM-YY'
                WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
                WHEN P_STYLE = 6   THEN  'DD Mon YY'
                WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
                WHEN P_STYLE = 7   THEN  'Mon DD, YY'
                WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
                WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
                WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
                WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 10  THEN  'MM-DD-YY'
                WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
                WHEN P_STYLE = 11  THEN  'YY/MM/DD'
                WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
                WHEN P_STYLE = 12  THEN  'YYMMDD'
                WHEN P_STYLE = 112 THEN  'YYYYMMDD'
                WHEN P_STYLE = 13  THEN  'DD Mon YYYY HH24:MI:SS:FF3'
                WHEN P_STYLE = 113 THEN  'DD Mon YYYY HH24:MI:SS:FF3'
                WHEN P_STYLE = 14  THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 114 THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 20  THEN  'YYYY-MM-DD HH24:MI:SS'
                WHEN P_STYLE = 120 THEN  'MM/DD/YY  HH12:MI:SS AM'
                WHEN P_STYLE = 21  THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
                WHEN P_STYLE = 22  THEN  'MM/DD/YY  FMHH12:MI:SS AM'
                WHEN P_STYLE = 122 THEN  'MM/DD/YY  FMHH12:MI:SS AM'
                WHEN P_STYLE = 23  THEN  'YYYY-MM-DD'
                WHEN P_STYLE = 123 THEN  'YYYY-MM-DD'
                WHEN P_STYLE = 121 THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
                WHEN P_STYLE = 126 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
                WHEN P_STYLE = 127 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
                WHEN P_STYLE = 130 THEN  'DD Mon YYYY HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 131 THEN  'DD/MM/YY HH12:MI:SS:FF3AM' 
                END;
END IF;


RETURN V_FORMAT;                
END;

FUNCTION CONVERT_STRING_TO_TIMESTAMPTZ (ARG VARCHAR2) RETURN TIMESTAMP WITH TIME ZONE
  AS
  BEGIN
   FOR i in DT_FORMATS.FIRST .. DT_FORMATS.LAST
   LOOP
    BEGIN
      RETURN TO_TIMESTAMP_TZ(ARG,DT_FORMATS(i));
   EXCEPTION
   WHEN OTHERS THEN
      NULL; -- Keep Trying
    END;
   END LOOP;
   --Attempt to cast one last time, but its really to designed to throw the error to the application when a string is not recognized
   RETURN  TO_TIMESTAMP_TZ(ARG,DT_FORMATS(1));
END; 

FUNCTION getNLSTSformat RETURN VARCHAR2
IS
 ts_format VARCHAR2(50);
BEGIN
  SELECT VALUE INTO ts_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_TIMESTAMP_FORMAT';
  RETURN ts_format;
END getNLSTSformat;

FUNCTION getNLSTSTZformat RETURN VARCHAR2
IS
 tstz_format VARCHAR2(50);
BEGIN
  SELECT VALUE INTO tstz_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_TIMESTAMP_TZ_FORMAT';
  RETURN tstz_format;
END getNLSTSTZformat;

FUNCTION getNLSDATEformat RETURN VARCHAR2
IS
 dt_format VARCHAR2(50);
BEGIN
  SELECT VALUE INTO dt_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_DATE_FORMAT';
  RETURN DT_FORMAT;
END getNLSDATEformat;

FUNCTION PI RETURN NUMBER
IS
    pi NUMBER := 3.141592653589793116;
BEGIN
    RETURN PI;
END PI;


FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2
IS
    l_number NUMBER;
  BEGIN
    l_number       := P_EXPR;
    -- Need to make sure that we protect against limitation on boundary condition
    IF l_number    <= -2147483647 THEN
      l_number     := -2147483647;
    ELSIF l_number >= 2147483647 THEN
      l_number     := 2147483647;
    END IF;
    RETURN RAWTOHEX(UTL_RAW.CAST_FROM_BINARY_INTEGER(l_number)) ;
END;

FUNCTION BIGINTTOHEX(P_EXPR RAW) RETURN VARCHAR2
IS
BEGIN
  RETURN RAWTOHEX(P_EXPR);
END biginttohex;

FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
IS
BEGIN
RETURN  UTL_RAW.BIT_XOR(p_raw1,p_raw2);
END;

FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER
IS BEGIN
RETURN BIT_OR(P_NUM1,P_NUM2) - BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW) RETURN RAW
IS BEGIN
RETURN  UTL_RAW.BIT_OR(p_raw1,p_raw2);
END;

FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER
IS BEGIN
RETURN P_NUM1 + P_NUM2 - BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
IS BEGIN
RETURN  UTL_RAW.BIT_AND(p_raw1,p_raw2);
END;

FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER 
IS BEGIN
RETURN  BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_COMPLIMENT(P_RAW1 RAW) RETURN RAW
IS BEGIN
  RETURN UTL_RAW.BIT_COMPLEMENT(p_raw1);
END;

FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER
IS BEGIN
RETURN  -(P_NUM1 +1);
END;

FUNCTION CONVERT_TO_DATE(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_DATE(P_EXPR IN TIMESTAMP	              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_DATE(P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_DATE(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS
   v_format VARCHAR2(50);
BEGIN
      IF P_STYLE IS NOT NULL THEN
        V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
        RETURN TO_DATE(P_EXPR, V_FORMAT);
      ELSE
        RETURN CAST(CONVERT_STRING_TO_TIMESTAMPTZ(P_EXPR) AS DATE);
      END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END;


FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TIMESTAMP	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP
IS
   v_format VARCHAR2(50);
BEGIN
    IF P_STYLE IS NOT NULL THEN
      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
      RETURN TO_TIMESTAMP(P_EXPR, V_FORMAT);
    ELSE
      RETURN CAST(CONVERT_STRING_TO_TIMESTAMPTZ(P_EXPR) AS TIMESTAMP);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END;


FUNCTION CONVERT_TO_TIMESTAMP_TZ(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP_TZ(P_EXPR IN TIMESTAMP	              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP_TZ(P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP_TZ(P_EXPR IN VARCHAR2	               , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TIMESTAMP WITH TIME ZONE 
IS
   v_format VARCHAR2(50);
BEGIN
   IF P_STYLE IS NOT NULL THEN
      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
      RETURN TO_TIMESTAMP_TZ(P_EXPR, V_FORMAT);
   ELSE
      RETURN CONVERT_STRING_TO_TIMESTAMPTZ(P_EXPR);
   END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);   
END;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
IS BEGIN
  return P_EXPR;
END;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
IS BEGIN
  return p_expr;
END;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN FLOAT  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
IS BEGIN
  RETURN P_EXPR;
END;


---
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS
   v_format VARCHAR2(50);
   v_result VARCHAR2(100);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  IF P_PRECISION <> 0 THEN
    v_result := SUBSTR(v_result,1,p_precision);
  END IF;
  RETURN v_result;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS
   v_format VARCHAR2(50);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    RETURN TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    RETURN TO_CHAR(P_EXPR);
  END IF;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS
   v_format VARCHAR2(50);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    RETURN TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    RETURN TO_CHAR(P_EXPR);
  END IF;
END;


FUNCTION CONVERT_TO_NUMBER(P_BLOB_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS
  v_expr RAW(32767);
BEGIN
    v_expr := DBMS_LOB.SUBSTR(P_BLOB_EXPR);
    -- v_expr := REGEXP_REPLACE(v_expr, '0x', '', 1, 1, 'i');
    RETURN UTL_RAW.CAST_TO_BINARY_INTEGER (v_expr, 3);  -- where 3 is machine_endian
END;

FUNCTION CONVERT_TO_BLOB(P_EXPR IN NUMBER, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
IS
BEGIN
   RETURN UTL_RAW.CAST_FROM_BINARY_INTEGER(P_EXPR, 3); -- where 3 is machine_endian
END;

FUNCTION CONVERT_TO_VARCHAR2(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN VARCHAR2
IS
  v_expr RAW(32767);
BEGIN
   v_expr := DBMS_LOB.SUBSTR(P_EXPR);
   RETURN UTL_RAW.CAST_TO_VARCHAR2(v_expr);
END;

FUNCTION CONVERT_TO_BLOB(P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_RAW(P_EXPR);
END;

FUNCTION SUBSTR_(P_EXPR IN VARCHAR2,P_PRECISION IN NUMBER DEFAULT NULL) RETURN CHAR
AS
BEGIN
  IF P_PRECISION IS  NULL THEN
    RETURN SUBSTR(P_EXPR,1,DEFAULT_CHAR_SIZE);
  ELSE
    RETURN SUBSTR(P_EXPR,1,P_PRECISION);
  END IF;
END;
--- MASTER CONVERT_TO_CHAR for DATETIME values
FUNCTION CONVERT_TO_CHAR_(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
V_FORMAT VARCHAR2(100);
V_RESULT VARCHAR2(4000);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  
  RETURN SUBSTR_(v_result,P_PRECISION);
END;
---
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL  , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS BEGIN
  RETURN  SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
   v_format VARCHAR2(50);
   v_result CHAR(4000);
BEGIN
   RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
   v_format VARCHAR2(50);
BEGIN
   RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
   v_format VARCHAR2(50);
BEGIN
  RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
END;   

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
  RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
  RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
END;

--- MASTER CONVERT_TO_CLOB for DATETIME values
FUNCTION CONVERT_TO_CLOB_(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
V_FORMAT VARCHAR2(100);
V_RESULT VARCHAR2(4000);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  
  RETURN SUBSTR_(v_result,P_PRECISION);
END;
---
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000 , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
  RETURN  SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
   v_format VARCHAR2(50);
   v_result CHAR(4000);
BEGIN
   RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TIMESTAMP		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
   v_format VARCHAR2(50);
BEGIN
   RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TIMESTAMP WITH TIME ZONE	, P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
   v_format VARCHAR2(50);
BEGIN
  RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

-- commented out for now as it returns null
--FUNCTION CONVERT_TO_CHAR(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN CHAR
--IS
--BEGIN
--     RETURN SUBSTR_(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE), P_PRECISION);
--END;

FUNCTION datename_(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN VARCHAR2
IS
  v_part VARCHAR2(15);
  v_timestamp TIMESTAMP WITH TIME ZONE := p_date_expr;
  v_wkday VARCHAR2(10);
  v_year VARCHAR2(4);
  v_temp VARCHAR2(30);
BEGIN
      v_part := UPPER(p_part_expr);
      IF v_part IN ('YEAR', 'YY', 'YYYY') THEN RETURN TO_CHAR(v_timestamp, 'YYYY');
      ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN RETURN TO_CHAR(v_timestamp, 'Q');
      ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_CHAR(v_timestamp, 'Month');
      ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
      ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_CHAR(v_timestamp, 'DD');
      ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_CHAR(v_timestamp, 'Day');
      ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
         -- commented out this code for now needs to be reviewed if the
         -- result is not consistent with sybase function call datename(wk,getdate())
         -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
         /*
         v_year := TO_CHAR(v_timestamp, 'YYYY');
         v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, 'MM-DD-YYYY'), 'DAY');
         IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
            RETURN TO_CHAR(v_timestamp, 'WW');
         ELSE
            RETURN TO_CHAR(v_timestamp, 'WW') + 1;
         END IF;
         
         RETURN TO_CHAR(v_timestamp, 'WW');
      ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_CHAR(v_timestamp, 'fmHH24');
      ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_CHAR(v_timestamp, 'fmMI');
      ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_CHAR(v_timestamp, 'fmSS');
      ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF3');
          IF v_temp = '000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;   
      ElSIF v_part IN ('MICROSECOND', 'MCS', 'FF6') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF6');
          IF v_temp = '000000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;
      ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF9');
          IF v_temp = '000000000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;
      ElSIF v_part IN ('TZOFFSET', 'TZ') THEN RETURN TO_CHAR(v_timestamp, 'TZH') || ':' || TO_CHAR(v_timestamp, 'TZM');
      ELSE
        RETURN NULL;
      END IF;

EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
END datename_;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2) 
RETURN VARCHAR2
IS
    v_part VARCHAR2(15);
    v_date DATE;
    v_tstz TIMESTAMP (9) WITH TIME ZONE;
    v_wkday VARCHAR2(10);
    v_year VARCHAR2(4);
BEGIN
      v_tstz := CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_date_str));   
      RETURN datename_(p_part_expr, v_tstz);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
END datename;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN DATE) 
RETURN VARCHAR2
IS
BEGIN
    RETURN datename_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END datename;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP) 
RETURN VARCHAR2
IS
BEGIN
   RETURN datename_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END datename;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP WITH TIME ZONE) 
RETURN VARCHAR2
IS
BEGIN
   RETURN datename_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END datename;

FUNCTION datepart_(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
  v_part VARCHAR2(15) := p_part_expr;
  v_timestamp TIMESTAMP WITH TIME ZONE := p_date_expr;
  v_wkday VARCHAR2(10);
  v_year VARCHAR2(4);
BEGIN
      v_part := UPPER(p_part_expr);
      IF v_part IN ('YEAR', 'YY', 'YYYY') THEN  RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'YYYY'));
      ELSIF v_part IN ('QUARTER', 'QQ', 'Q')  THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'Q'));
      ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MM'));
      ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
      ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DD'));
      ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D'));
      -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
      ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN  
         v_year := TO_CHAR(v_timestamp, 'YYYY');
         v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, 'MM-DD-YYYY'), 'DAY');
         IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
            RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW'));
         ELSE
            RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW')) + 1;
         END IF; 
      ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'HH24'));
      ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MI'));
      ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'SS'));
      ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF3'));
      ElSIF v_part IN ('MICROSECOND', 'MCS', 'US', 'FF6') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF6'));
      ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF9'));
      ElSIF v_part IN ('CALYEAROFWEEK', 'CYR', 'IYYY') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IYYY')); 
      ElSIF v_part IN ('CALWEEKOFYEAR', 'CWK', 'IW') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IW'));
      -- Oracle returns 1 more when compared to Sybase so subtract 1 to the result.
      ElSIF v_part IN ('CALDAYOFWEEK', 'CDW', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D')) - 1;
      ELSE
        RETURN NULL;
      END IF;

EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END datepart_;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2)
RETURN NUMBER
IS
   v_tstz TIMESTAMP WITH TIME ZONE;
BEGIN  
      v_tstz := CONVERT_STRING_TO_TIMESTAMPTZ(p_date_str);
      RETURN datepart_(p_part_expr, v_tstz);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END datepart;


FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP)
RETURN NUMBER
IS
BEGIN
    RETURN datepart_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datepart;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN datepart_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datepart;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN TIMESTAMP WITH TIME ZONE) 
RETURN NUMBER 
IS
BEGIN
   RETURN datepart_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datepart;

FUNCTION dateadd_(p_interval IN VARCHAR2,  p_interval_val IN NUMBER, p_date_exp IN TIMESTAMP WITH TIME ZONE)
RETURN TIMESTAMP 
IS
  v_ucase_interval VARCHAR2(10);
  v_date TIMESTAMP;
  v_datestr VARCHAR2(30);
  v_result TIMESTAMP;
BEGIN
    v_date := CAST(p_date_exp AS TIMESTAMP);
    v_ucase_interval := UPPER(p_interval);
      
    IF v_ucase_interval IN ('YEAR', 'YY', 'YYYY') 
    THEN
      RETURN ADD_MONTHS(v_date, p_interval_val * 12);
    ELSIF v_ucase_interval IN ('QUARTER', 'QQ', 'Q') 
    THEN
      IF LAST_DAY(v_date) = v_date THEN
         v_datestr := EXTRACT(MONTH FROM v_date) + (p_interval_val * 3);
         v_datestr := v_datestr || '-' || EXTRACT(DAY FROM v_date) || '-' || EXTRACT(YEAR FROM v_date);
         v_datestr := v_datestr || ' ' || TO_CHAR(v_date, 'HH12') || ':' || TO_CHAR(v_date, 'MI') || ':' || TO_CHAR(v_date, 'SS');
         v_datestr := v_datestr || '.' || TO_CHAR(v_date, 'FF3 AM') ;
         v_result := TO_TIMESTAMP(v_datestr, 'MM-DD-YYYY HH12:MI:SS.FF3 AM');
         RETURN v_result;
      ELSE
         RETURN ADD_MONTHS(v_date, p_interval_val * 3);
      END IF;   
    ELSIF v_ucase_interval IN ('MONTH', 'MM', 'M') 
    THEN
      BEGIN
      --handle negative number
      IF p_interval_val < 0 THEN
        -- v_result := v_date - TO_YMINTERVAL('00-'||p_interval_val * -1);
         v_result := v_date + NUMTOYMINTERVAL(p_interval_val * -1, 'MONTH') + NUMTODSINTERVAL(0, 'HOUR');
      ELSE
        --v_result := v_date + TO_YMINTERVAL('00-'||p_interval_val);
         v_result := v_date + NUMTOYMINTERVAL(p_interval_val, 'MONTH') + NUMTODSINTERVAL(0, 'HOUR');
      END IF;
      EXCEPTION WHEN OTHERS THEN
       --problem due to resulting date not being able to handle a particular day like (Ex: Feb 31)
       v_result := ADD_MONTHS(v_date, p_interval_val) ; -- this will use the last valid day (Ex: Feb 28)
      END;
      RETURN v_result;
    ElSIF v_ucase_interval IN ('DAYOFYEAR', 'DY', 'Y', 'DAY', 'DD', 'D', 'WEEKDAY', 'DW', 'W') 
    THEN
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'DAY');
    ElSIF v_ucase_interval IN ('WEEK', 'WK', 'WW') 
    THEN
      RETURN v_date + (p_interval_val * 7);
    ElSIF v_ucase_interval IN ('HOUR', 'HH') 
    THEN
      -- RETURN v_date + (p_interval_val / 24);
       RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'HOUR');
    ElSIF v_ucase_interval IN ('MINUTE', 'MI', 'N') 
    THEN
      -- RETURN v_date + NUMTODSINTERVAL((p_interval_val / 24 / 60), 'MINUTE');
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'MINUTE');
    ElSIF v_ucase_interval IN ('SECOND', 'SS', 'S') 
    THEN
      -- RETURN v_date + (p_interval_val / 24 / 60 / 60);
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'SECOND');
    ElSIF v_ucase_interval IN ('MILLISECOND', 'MS') 
    THEN
      -- result accurate to one three-hundredth of a second 
      RETURN v_date + NUMTODSINTERVAL(3.33 * ROUND(p_interval_val/3.33), 'SECOND')/1000;
    ELSE
      RETURN NULL;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END dateadd_;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_str IN VARCHAR2)
RETURN TIMESTAMP
IS
    v_tstz TIMESTAMP WITH TIME ZONE;
BEGIN
    v_tstz := CONVERT_STRING_TO_TIMESTAMPTZ(p_date_str);
    RETURN dateadd_(p_interval, p_interval_val, v_tstz);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN DATE)
RETURN DATE
IS
BEGIN
    RETURN CAST(dateadd_(p_interval, p_interval_val, p_date_expr) AS DATE);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN TIMESTAMP)
RETURN TIMESTAMP
IS  
BEGIN
    RETURN dateadd_(p_interval, p_interval_val, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN TIMESTAMP WITH TIME ZONE
IS
BEGIN
    RETURN dateadd_(p_interval, p_interval_val, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION degrees(p_angle_radians IN NUMBER) 
RETURN NUMBER
IS
BEGIN
    IF p_angle_radians IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN ROUND(p_angle_radians / pi() * 180);
EXCEPTION 
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END degrees;


--SQLSERVER
FUNCTION year_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMPTZ(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN TO_NUMBER(TO_CHAR(v_date, 'YYYY'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;


FUNCTION year_(p_date_expr IN DATE) 
RETURN NUMBER
IS
BEGIN
   RETURN EXTRACT(YEAR FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;


FUNCTION year_(p_date_expr IN TIMESTAMP)
RETURN NUMBER
IS
BEGIN
   RETURN EXTRACT(YEAR FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;

FUNCTION year_(p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
BEGIN
   RETURN EXTRACT(YEAR FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;


FUNCTION difference(p_expr1 IN VARCHAR2, p_expr2 IN VARCHAR2)
RETURN NUMBER
IS
    sound_ex_val_1 CHAR(4);
    sound_ex_val_2 CHAR(4);
    similarity NUMBER := 0;
    idx NUMBER := 1; 
BEGIN
    IF p_expr1 IS NULL OR p_expr2 IS NULL THEN
       RETURN NULL;
    END IF;
    
    sound_ex_val_1 := SOUNDEX(p_expr1);
    sound_ex_val_2 := SOUNDEX(p_expr2);
    
    LOOP
       IF SUBSTR(sound_ex_val_1, idx, 1) = SUBSTR(sound_ex_val_2, idx, 1) THEN
          similarity := similarity + 1;
       END IF;
       
       idx := idx + 1;   
       EXIT WHEN idx > 4;
    END LOOP;
    
    RETURN similarity;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END difference;


FUNCTION datediff_(p_datepart IN VARCHAR2, p_start_date_expr IN TIMESTAMP WITH TIME ZONE, p_end_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
    v_ret_value NUMBER := NULL;
    v_part VARCHAR2(15);
    v_start_ts_tz  TIMESTAMP WITH TIME ZONE;
    v_end_ts_tz  TIMESTAMP WITH TIME ZONE;
    v_start_date  DATE;
    v_end_date  DATE;
BEGIN
    v_part := p_datepart;
    v_start_ts_tz := p_start_date_expr;
    v_end_ts_tz := p_end_date_expr;
    v_start_date := TO_DATE(EXTRACT(YEAR FROM v_start_ts_tz) || '-' || EXTRACT(MONTH FROM v_start_ts_tz) || '-' || EXTRACT(DAY FROM v_start_ts_tz), 'YYYY-MM-DD');
    v_end_date := TO_DATE(EXTRACT(YEAR FROM v_end_ts_tz) || '-' || EXTRACT(MONTH FROM v_end_ts_tz) || '-' || EXTRACT(DAY FROM v_end_ts_tz), 'YYYY-MM-DD');
    v_part := UPPER(p_datepart);
    
    IF v_part IN ('YEAR', 'YY', 'YYYY') THEN
      IF EXTRACT(YEAR FROM v_end_ts_tz) - EXTRACT(YEAR FROM v_start_ts_tz) = 1 AND
        EXTRACT(MONTH FROM v_start_ts_tz) = 12 AND EXTRACT(MONTH FROM v_end_ts_tz) = 1 AND
        EXTRACT(DAY FROM v_start_ts_tz) = 31 AND EXTRACT(DAY FROM v_end_ts_tz) = 1 THEN
        -- When comparing December 31 to January 1 of the immediately succeeding year, 
        -- DateDiff for Year ("yyyy") returns 1, even though only a day has elapsed.
        v_ret_value := 1;
      ELSE
        v_ret_value := ROUND(MONTHS_BETWEEN(v_end_ts_tz, v_start_ts_tz) / 12);
      END IF;
    ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN
       v_ret_value := ROUND(MONTHS_BETWEEN(v_end_ts_tz, v_start_ts_tz) / 3);
    ELSIF v_part IN ('MONTH', 'MM', 'M') THEN
       v_ret_value := ROUND(MONTHS_BETWEEN(TRUNC(v_end_ts_tz, 'MM'), TRUNC(v_start_ts_tz, 'MM')));
     ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN
       v_ret_value := ROUND(CAST(v_end_ts_tz AS DATE) - CAST(v_start_ts_tz AS DATE));
    ElSIF v_part IN ('DAY', 'DD', 'D') THEN
       v_ret_value := ROUND(v_end_date - v_start_date);
    ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
       v_ret_value := ROUND((CAST(v_end_ts_tz AS DATE) - CAST(v_start_ts_tz AS DATE)) / 7);
    ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN
       -- v_ret_value := TO_CHAR(v_end_ts_tz, 'D') - TO_CHAR(v_start_ts_tz, 'D');
       -- In Sybase the result is similar to using date part 'Week 'or 'wk' in datediff function
       IF EXTRACT(YEAR FROM v_end_ts_tz) = EXTRACT(YEAR FROM v_start_ts_tz) THEN
          v_ret_value := EXTRACT(DAY FROM v_end_ts_tz) - EXTRACT(DAY FROM v_start_ts_tz);
       ELSE
          v_ret_value := ROUND((TRUNC(v_end_ts_tz, 'DD') - TRUNC(v_start_ts_tz, 'DD')) / 7);
       END IF;
    ElSIF v_part IN ('HOUR', 'HH') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24;
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz))));
    ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz)) * 60);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts_tz) - EXTRACT(MINUTE FROM v_start_ts_tz))));
    ElSIF v_part IN ('SECOND', 'SS', 'S') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz)) * 60 * 60);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts_tz) - EXTRACT(MINUTE FROM v_start_ts_tz)) * 60);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts_tz) - EXTRACT(SECOND FROM v_start_ts_tz))));
    ElSIF v_part IN ('MILLISECOND', 'MS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz)) * 60 * 60 * 1000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts_tz) - EXTRACT(MINUTE FROM v_start_ts_tz)) * 60 * 1000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts_tz) - EXTRACT(SECOND FROM v_start_ts_tz)) * 1000));
    ElSIF v_part IN ('MICROSECOND', 'MCS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz)) * 60 * 60 * 1000000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts_tz) - EXTRACT(MINUTE FROM v_start_ts_tz)) * 60 * 1000000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts_tz) - EXTRACT(SECOND FROM v_start_ts_tz)) * 1000000));
    ElSIF v_part IN ('NANOSECOND', 'NS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts_tz) - EXTRACT(HOUR FROM v_start_ts_tz)) * 60 * 60 * 1000000000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts_tz) - EXTRACT(MINUTE FROM v_start_ts_tz)) * 60 * 1000000000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts_tz) - EXTRACT(SECOND FROM v_start_ts_tz)) * 1000000000));
    END IF;
    RETURN v_ret_value;
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff_;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_str IN VARCHAR2, p_end_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_start_ts_tz  TIMESTAMP WITH TIME ZONE;
    v_end_ts_tz  TIMESTAMP WITH TIME ZONE;
BEGIN
  v_start_ts_tz := CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_start_date_str));
  v_end_ts_tz := CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_end_date_str));
   RETURN datediff_(p_datepart, v_start_ts_tz, v_end_ts_tz);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN DATE, p_end_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
      RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN TIMESTAMP, p_end_date_expr IN TIMESTAMP)
RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN TIMESTAMP WITH TIME ZONE, p_end_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;


FUNCTION datediff(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_start_date_str)), p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_start_date_str)), p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_start_date_str)), p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;


FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_end_date_str)));
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

 
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_end_date_str)));
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP, P_END_DATE_EXPR IN TIMESTAMP WITH TIME ZONE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;


FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_EXPR IN TIMESTAMP) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TIMESTAMP WITH TIME ZONE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMPTZ(TRIM(p_end_date_str)));
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION month_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
    v_dateformat VARCHAR2(50);
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMPTZ(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN TO_NUMBER(TO_CHAR(v_date, 'MM'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION month_(p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(MONTH FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION month_(p_date_expr IN TIMESTAMP)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(MONTH FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION month_(p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(MONTH FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;


-- PUBLIC NOT REFACTORED YET
FUNCTION rand(p_seed NUMBER DEFAULT NULL)
RETURN NUMBER
IS
    v_rand_num NUMBER;
BEGIN
      IF p_seed IS NOT NULL THEN
         DBMS_RANDOM.SEED(p_seed);
      END IF;
      
      v_rand_num := DBMS_RANDOM.VALUE();
      
      RETURN v_rand_num;
EXCEPTION
     WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END rand;

PROCEDURE resetTrancount
IS
BEGIN	
   trancount := 0;
END resetTrancount;

FUNCTION isnumeric(p_expr IN VARCHAR2)
RETURN NUMBER
IS
    numeric_val NUMBER;
    temp_str VARCHAR2(50);
BEGIN
    temp_str := p_expr;
    IF SUBSTR(temp_str, 1, 1) = '$' THEN
       temp_str := SUBSTR(temp_str, 2);
    END IF;
    
    numeric_val := TO_NUMBER(temp_str);
    RETURN 1;
EXCEPTION
    WHEN OTHERS THEN
       RETURN 0;
END isnumeric;

FUNCTION stats_date(p_table IN VARCHAR2, p_index IN VARCHAR2)
RETURN DATE
IS
    v_last_analyzed DATE;
BEGIN
    SELECT last_analyzed INTO v_last_analyzed
      FROM USER_IND_STATISTICS
     WHERE table_name LIKE UPPER(p_table)
       AND index_name LIKE UPPER(p_index);
  
    RETURN v_last_analyzed;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END stats_date;


FUNCTION oct(p_num VARCHAR2)
RETURN VARCHAR2
IS
BEGIN
    RETURN to_base(p_num, 8);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END oct;

FUNCTION quotename(p_str IN VARCHAR2, p_delimiters IN VARCHAR2 DEFAULT '[]')
RETURN VARCHAR2
IS
    v_ret_val VARCHAR2(150) := NULL;
BEGIN
    IF p_delimiters = '[]' THEN
       v_ret_val := '[' || REPLACE(p_str, ']', ']]') || ']';
    ELSIF p_delimiters = '"' THEN
       v_ret_val := '"' || p_str || '"';
    ELSIF p_delimiters = '''' THEN
       v_ret_val := '''' || p_str || '''';
      END IF;
     
      RETURN v_ret_val;
EXCEPTION
      WHEN OTHERS THEN
         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END quotename;

FUNCTION parsename(p_object_name IN VARCHAR2, p_object_piece IN NUMBER)
RETURN VARCHAR2
IS
    ret_val VARCHAR2(150) := NULL;
    pos NUMBER;
    v_next_pos NUMBER;
BEGIN
    IF p_object_name IS NULL THEN 
       RETURN NULL;
    END IF;
    
    -- for 10g
    IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
      IF p_object_piece = 1 THEN -- object name
         ret_val := REGEXP_SUBSTR(p_object_name, '(^[^\.]+$)|(\.[^\.]+$)');
         ret_val := REPLACE(ret_val, '.', '');
      ELSIF p_object_piece = 2 THEN -- schema name
         ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]+$)');
         ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]+$)', '');
      ELSIF p_object_piece = 3 THEN -- database name
         ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]*)\.([^\.]+$)');
         ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]*)\.([^\.]+$)', '');
      ELSIF p_object_piece = 4 THEN -- server name
         ret_val := REGEXP_SUBSTR(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)');
         IF ret_val IS NOT NULL THEN
           ret_val := REGEXP_REPLACE(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)', '\1');
         END IF;
      END IF;
    ELSE
      ret_val := p_object_name;
      v_next_pos := LENGTH(p_object_name);
      FOR i IN 1 .. p_object_piece LOOP
        pos := INSTR(p_object_name, '.', -1, i);
        IF pos > 0 THEN
          ret_val := SUBSTR(p_object_name, pos + 1, v_next_pos - pos);
        END IF;
        v_next_pos := pos;
      END LOOP;
      
      IF LENGTH(ret_val) = 0 THEN
        RETURN NULL;
      END IF;
    END IF;
    
    RETURN ret_val;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END PARSENAME;

FUNCTION fetch_status(p_cursorfound IN BOOLEAN)
RETURN NUMBER
IS
     v_fetch_status NUMBER := 0;
BEGIN
   CASE
     WHEN p_cursorfound THEN
        v_fetch_status := 0; --fetch successful
     ELSE
        v_fetch_status := -1; --fetch unsuccessful
     END CASE;
     RETURN v_fetch_status;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END fetch_status;

FUNCTION sqlstatus(p_cursorfound IN BOOLEAN,p_cursoropen IN BOOLEAN)
RETURN NUMBER
IS
     v_sqlerror NUMBER := 0;
BEGIN
   CASE
     WHEN NOT p_cursoropen THEN
        v_sqlerror := 1; -- fetch statement resulted in an error
     WHEN p_cursorfound THEN
        v_sqlerror := 0; --successful completion
     ELSE 
 		v_sqlerror :=2;  --no more data in result set
     END CASE;
     RETURN v_sqlerror;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END sqlstatus;


FUNCTION ident_seed(p_sequence IN VARCHAR2)
RETURN NUMBER
IS
    v_seed NUMBER;
BEGIN
      SELECT min_value INTO v_seed
         FROM USER_SEQUENCES
         WHERE sequence_name LIKE UPPER(p_sequence);
  
      RETURN v_seed;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END IDENT_SEED;

FUNCTION to_base(p_dec NUMBER, p_base NUMBER) 
RETURN VARCHAR2
IS
    v_str VARCHAR2(255);
    v_num NUMBER;
    v_hex VARCHAR2(16) DEFAULT '0123456789ABCDEF';
BEGIN
    v_num := p_dec;
    
    IF p_dec IS NULL OR p_base IS NULL THEN
      RETURN NULL;
    END IF;

    IF TRUNC(p_dec) <> p_dec OR p_dec < 0 THEN
        RAISE PROGRAM_ERROR;
    END IF;
    
    LOOP
      v_str := SUBSTR(v_hex, MOD(v_num, p_base) + 1, 1) || v_str;
      v_num := TRUNC(v_num / p_base);
      
      EXIT WHEN v_num = 0;
    END LOOP;
    
    RETURN v_str;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END TO_BASE;

PROCEDURE decrementTrancount
IS
BEGIN	
	IF trancount > 0 THEN
      	trancount := trancount - 1;
   	END IF;
END decrementTrancount;

FUNCTION hex(p_num VARCHAR2)
RETURN VARCHAR2
IS
BEGIN
    RETURN to_base(p_num, 16);
  EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END hex;

FUNCTION isdate(p_expr IN VARCHAR2)
RETURN NUMBER
IS
     v_is_valid_date BINARY_INTEGER := 0;
BEGIN
    IF CONVERT_STRING_TO_TIMESTAMPTZ(p_expr) IS NOT NULL THEN
       RETURN 1;
    ELSE 
       SELECT NVL2(TO_DATE(p_expr), 1, 0) INTO v_is_valid_date FROM DUAL;
       RETURN v_is_valid_date;
    END IF;    
EXCEPTION 
    WHEN OTHERS THEN
       RETURN 0;
END isdate;

FUNCTION radians(p_degree IN NUMBER)
RETURN NUMBER
IS
    v_rad NUMBER;
BEGIN
    v_rad := p_degree / 180 * pi();
    
    IF INSTR(TO_CHAR(p_degree),'.') = 0 THEN
        v_rad := FLOOR(v_rad);
    ELSE 
        v_rad := round(p_degree / 180 * pi(),18); 
    END IF;
      
    RETURN v_Rad ;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END radians;

FUNCTION GETIDENTITY RETURN NUMBER
IS
BEGIN
 RETURN IDENTITY;
END;

FUNCTION ident_incr(p_sequence IN VARCHAR2)
RETURN NUMBER
IS
    v_incr_by NUMBER;
BEGIN
    SELECT increment_by INTO v_incr_by
       FROM USER_SEQUENCES
       WHERE sequence_name LIKE UPPER(p_sequence);

    RETURN v_incr_by;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END ident_incr;

FUNCTION day_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMPTZ(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN TO_NUMBER(TO_CHAR(v_date, 'DD'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION day_(p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(DAY FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION day_(p_date_expr IN TIMESTAMP)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(DAY FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION day_(p_date_expr IN TIMESTAMP WITH TIME ZONE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(DAY FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION stuff(p_expr VARCHAR2, p_startIdx NUMBER, p_len NUMBER, p_replace_expr VARCHAR2) 
RETURN VARCHAR2
IS
BEGIN
       RETURN REPLACE(p_expr, SUBSTR(p_expr, p_startIdx, p_len), p_replace_expr);
EXCEPTION
        WHEN OTHERS THEN
          raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END stuff;
PROCEDURE commit_transaction
IS
BEGIN	
   IF trancount <= 1 THEN
        COMMIT;
   END IF;
   resetTrancount;
END commit_transaction;

FUNCTION round_(p_expr NUMBER, p_len NUMBER, p_function NUMBER DEFAULT 0) 
RETURN NUMBER
IS
    v_ret_value NUMBER;
BEGIN
      IF p_function = 0 THEN
         v_ret_value := ROUND(p_expr, p_len);
      ELSE
         v_ret_value := TRUNC(p_expr, p_len);
      END IF;
      
      RETURN v_ret_value;
EXCEPTION
     WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END round_;

FUNCTION patindex(p_pattern IN VARCHAR2, p_expr IN VARCHAR2, p_format IN VARCHAR2)
RETURN NUMBER
IS
    v_search_pattern VARCHAR2(100);
    v_pos NUMBER := 0;
    v_charsfmt VARCHAR2(20) := 'using chars';
    v_charactersfmt  VARCHAR2(20) := 'using characters';
    v_bytesfmt VARCHAR2(20) := 'using bytes';
    v_format VARCHAR2(20);
    v_errmsg VARCHAR2(50) := 'Invalid format: ';
BEGIN
      IF p_pattern IS NULL OR p_expr IS NULL THEN
         RETURN NULL;
      END IF;
      
      IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
        v_search_pattern := p_pattern;
        v_search_pattern := REPLACE(v_search_pattern, '\', '\\');
        v_search_pattern := REPLACE(v_search_pattern, '*', '\*');
        v_search_pattern := REPLACE(v_search_pattern, '+', '\+');
        v_search_pattern := REPLACE(v_search_pattern, '?', '\?');
        v_search_pattern := REPLACE(v_search_pattern, '|', '\|');
        v_search_pattern := REPLACE(v_search_pattern, '^', '\^');
        v_search_pattern := REPLACE(v_search_pattern, '$', '\$');
        v_search_pattern := REPLACE(v_search_pattern, '.', '\.');
        v_search_pattern := REPLACE(v_search_pattern, '{', '\{');
        v_search_pattern := REPLACE(v_search_pattern, '_', '.');
              
        v_format := lower(p_format);
        IF v_format = v_charsfmt OR v_format = v_charactersfmt THEN
           IF SUBSTR(v_search_pattern, 1, 1) != '%' AND 
              SUBSTR(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := '^' || v_search_pattern || '$';
           ELSIF SUBSTR(v_search_pattern, 1, 1) != '%' THEN
               v_search_pattern := '^' || SUBSTR(v_search_pattern, 1, LENGTH(v_search_pattern) - 1);
           ELSIF SUBSTR(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := SUBSTR(v_search_pattern, 2) || '$';
           ELSE
               v_search_pattern := SUBSTR(v_search_pattern, 2, LENGTH(v_search_pattern) - 2);
           END IF;    
        ELSIF v_format = v_bytesfmt THEN    
           IF SUBSTRB(v_search_pattern, 1, 1) != '%' AND 
              SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := '^' || v_search_pattern || '$';
           ELSIF SUBSTRB(v_search_pattern, 1, 1) != '%' THEN
               v_search_pattern := '^' || SUBSTRB(v_search_pattern, 1, LENGTHB(v_search_pattern) - 1);
           ELSIF SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := SUBSTRB(v_search_pattern, 2) || '$';
           ELSE
               v_search_pattern := SUBSTRB(v_search_pattern, 2, LENGTHB(v_search_pattern) - 2);
           END IF;    
        ELSE
            v_errmsg := v_errmsg || p_format;
            raise_application_error(-20001, v_errmsg);
        END IF;
        v_pos := REGEXP_INSTR(p_expr, v_search_pattern);
      ELSE 
        v_pos := 0;
      END IF;
      
      RETURN v_pos;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END patindex;
PROCEDURE incrementTrancount
IS
BEGIN	
   trancount := trancount + 1;
END INCREMENTTRANCOUNT;





FUNCTION reverse_(p_expr IN VARCHAR2)
RETURN VARCHAR2
IS
    v_result VARCHAR2(2000) := NULL;
BEGIN      
    FOR i IN 1..LENGTH(p_expr) LOOP
      v_result := v_result || SUBSTR(p_expr, -i, 1);
    END LOOP;
  
    RETURN v_result;    
EXCEPTION 
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END reverse_;

PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2)
AS
BEGIN
DATABASE_TYPE := P_DATABASE_TYPE;
END SET_DATABASE_TYPE;

FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2
IS
    v_ret_val VARCHAR2(50);
    v_temp_val NUMBER;
    v_format_str VARCHAR2(50);
    v_len NUMBER;
    v_val NUMBER;
    v_has_decimal BOOLEAN := FALSE;
BEGIN
      IF INSTR(TO_CHAR(p_expr), '.') > 0 THEN
        v_has_decimal := TRUE;
        v_len := LENGTH(SUBSTR(TO_CHAR(p_expr), 1, INSTR(TO_CHAR(p_expr), '.')-1));
      ELSE
        v_len := LENGTH(TO_CHAR(p_expr));
      END IF;  
      
      IF p_len < v_len THEN
         RETURN TRIM(LPAD(' ', p_len+1,'*'));
      END IF;
      
      v_temp_val := p_expr;
      IF p_len >= v_len THEN
         v_temp_val := ROUND(v_temp_val, p_scale);
      ELSE
         v_temp_val := ROUND(v_temp_val, 0);
      END IF;   
      
      IF p_scale > 0 AND v_has_decimal THEN
         IF v_len >= (p_len - p_scale) THEN
             v_format_str := LPAD(' ', v_len+1, '9');
         ELSE    
             v_format_str := LPAD(' ', (p_len - p_scale), '9');
         END IF;
         v_format_str := TRIM(v_format_str);
         IF INSTR(TO_CHAR(p_expr), '.') != p_len THEN 
           v_format_str := v_format_str || '.';
           v_format_str := RPAD(v_format_str, p_len, '9');
         END IF;  
      ELSE
         v_format_str := TRIM(LPAD(' ', p_len+1, '9'));
      END IF;
      v_ret_val := TO_CHAR(v_temp_val, v_format_str);
      RETURN v_ret_val;
EXCEPTION 
      WHEN OTHERS THEN
        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END STR;

BEGIN

-- Datetime formats/styles starting with DAY only --
DT_DAY := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fxfmdd/mm/yy',                    --British/French
'fxfmdd/mm/yyyy',                  --British/French(with Century)
'fxfmdd.mm.yy',                    --German(without Century)
'fxfmdd.mm.yyyy',                  --German(with Century)
'fxfmdd-mm-yy',                    --Italian(without Century)
'fxfmdd-mm-yyyy',                  --Italian(with Century)
'fxfmdd mon yy',                   --(without Century)
'fxfmdd mon yyyy',                 --(with Century)
'dd mon yyyy hh24:mi:ssxff3',      --Europe default+milliseconds
'fxdd mon yyyy hh12:mi:ss:ff3AM',  --Hijri calendar system 
'fxdd/mm/yy hh12:mi:ss:ff3AM',     --Hijri calendar system 

-------- Some more DateTime formats that were addressed before --------
'fmdd yyyy MONTH',

----------------- Additional DateTime formats ------------------------- 
'fmdd Month',
'fmdd Month yy',
'fmdd Month yyyy',
'fxddmmyy',
'fxddmmyyyy',
'fxdd-Mon-yy',
'fxdd-MON-yy',
'fxdd-Mon-yyyy',
'fxdd-MON-yyyy'
);

-- Datetime formats/styles starting with MONTH only --
DT_MONTH := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fmmon dd yyyy hh:miAM',           --Default   
'fxfmmm/dd/yy',                    --US(without Century)
'fxfmmm/dd/yyyy',                  --US(with Century)
'fxfmMon dd, yy',                  --(without Century)
'fxfmMon dd, yyyy',                --(with Century)
'mon dd yyyy hh12:mi:ssxff3am',    --Default+milliseconds
'fxfmmm-dd-yy',                    --US(without Century)
'fxfmmm-dd-yyyy',                  --US(with Century)

-------- Some more DateTime formats that were addressed before -------- 
'fmMONTH, yyyy',
'MON yyyy',
'fmMONTH dd, yyyy',
----------------- Additional DateTime formats ------------------------- 
'mm/yy',
'mm/yyyy',
'fmMonth dd, yyyy',             
'fmMonth dd',
'mm-yy',
'mm-yyyy',
'fxmmddyy',
'fxmmddyyyy',
'Mon-yy',
'Mon-yyyy',
'MON-yy',
'MON-yyyy'
);

-- Datetime formats/styles starting with YEAR only --
DT_YEAR := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fxfmyy.mm.dd',                    --ANSI(without Century)
'fxfmyyyy.mm.dd',                  --ANSI(with Century)
'fxfmyy/mm/dd',                    --Japan(without Century)
'fxfmyyyy/mm/dd',                  --Japan(with Century)
'yymmdd',                          --ISO(without Century)
'yyyymmdd',                        --ISO(with Century)
'fxyyyy-mm-dd hh24:mi:ss',         --ODBC canonical
'fxyyyy-mm-dd hh24:mi:ssxff3',     --ODBC canonical (with milliseconds)
'fxyyyy-mm-dd"T"hh12:mi:ssxff3',   --ISO8601 (no spaces)
'fxyyyy-mm-dd hh12:mi:ssxff3',     --ISO8601 (with space)
'fxyyyy-mm-dd hh12:mi:ssxff3tzr',  --ISO8601 with time zone Z

-------- Some more DateTime formats that were addressed before -------- 
'fxyyyymmdd hh24:mi:ss',
'fxyyyy-mm-dd',                    --ISO8601 Date only
'fxyyyy-mm-dd hh12:mi:ss',
'yyyy MON',

----------------- Additional DateTime formats ------------------------- 
'yy/mm',
'yyyy/mm',
'yy-mm',
'yyyy-mm'
);

-- TIME formats/styles --
DT_TIME := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'hh:mi:ss',
'hh24:mi:ssxff3',

-------- Some more Time formats that were addressed before ------------ 
'hh12 AM',                         --Time using Hour
'hh12:mi:ss AM'                    --Time
);

-- ORACLE Server NLS DATETIME FORMATS --
DT_NLS := VARCHAR2_ARRAY(
getNLSDATEformat,
getNLSTSformat,
getNLSTSTZformat
);

/*
 You can modify the DT_FORMATS as you wish.
 Put the most likely Datetime Formats or 
 Nested Table Type variables at the top.
 For e.g: 
   DT_FORMATS := DT_MONTH MULTISET UNION DT_NLS;
   DT_FORMATS := DT_YEAR MULTISET UNION DT_TIME;
   DT_FORMATS := VARCHAR2_ARRAY('mm-dd-yy');


DT_FORMATS := DT_MONTH MULTISET UNION DT_YEAR MULTISET UNION DT_NLS;
END utils;
/

create or replace  public  synonym utils for  emulation.utils;
/
grant execute on utils to public;
/ 

connect dbo_PERSONNEL/dbo_PERSONNEL;

-- DROP SEQUENCE departments_idDep_SEQ;


PROMPT Creating Sequence departments_idDep_SEQ ...
CREATE SEQUENCE  departments_idDep_SEQ  
  MINVALUE 1 MAXVALUE 999999999999999999999999 INCREMENT BY 1  NOCYCLE ;

-- DROP SEQUENCE posts_idPost_SEQ;


PROMPT Creating Sequence posts_idPost_SEQ ...
CREATE SEQUENCE  posts_idPost_SEQ  
  MINVALUE 1 MAXVALUE 999999999999999999999999 INCREMENT BY 1  NOCYCLE ;

-- DROP SEQUENCE specialty_idSpec_SEQ;


PROMPT Creating Sequence specialty_idSpec_SEQ ...
CREATE SEQUENCE  specialty_idSpec_SEQ  
  MINVALUE 1 MAXVALUE 999999999999999999999999 INCREMENT BY 1  NOCYCLE ;

-- DROP SEQUENCE gadm36_blr_2_ogr_fid_SEQ;


PROMPT Creating Sequence gadm36_blr_2_ogr_fid_SEQ ...
CREATE SEQUENCE  gadm36_blr_2_ogr_fid_SEQ  
  MINVALUE 1 MAXVALUE 999999999999999999999999 INCREMENT BY 1  NOCYCLE ;*/

-- DROP TABLE departments CASCADE CONSTRAINTS;


PROMPT Creating Table departments ...
CREATE TABLE departments (
  idDep NUMBER(10,0) NOT NULL,
  department VARCHAR2(50 CHAR),
  leader VARCHAR2(50 CHAR),
  phoneNum VARCHAR2(20 CHAR)
);


PROMPT Creating Primary Key Constraint idDep_pk on table departments ... 
ALTER TABLE departments
ADD CONSTRAINT idDep_pk PRIMARY KEY
(
  idDep
)
ENABLE
;

-- DROP TABLE posts CASCADE CONSTRAINTS;


PROMPT Creating Table posts ...
CREATE TABLE posts (
  idPost NUMBER(10,0) NOT NULL,
  post VARCHAR2(50 CHAR)
);



PROMPT Creating Primary Key Constraint idPost_pk on table posts ... 
ALTER TABLE posts
ADD CONSTRAINT idPost_pk PRIMARY KEY
(
  idPost
)
ENABLE
;

-- DROP TABLE specialty CASCADE CONSTRAINTS;


PROMPT Creating Table specialty ...
CREATE TABLE specialty (
  idSpec NUMBER(10,0) NOT NULL,
  specialty VARCHAR2(50 CHAR)
);


PROMPT Creating Primary Key Constraint idSpec_pk on table specialty ... 
ALTER TABLE specialty
ADD CONSTRAINT idSpec_pk PRIMARY KEY
(
  idSpec
)
ENABLE
;

-- DROP TABLE personal_inf CASCADE CONSTRAINTS;


PROMPT Creating Table personal_inf ...
CREATE TABLE personal_inf (
  personalNum NUMBER(10,0) NOT NULL,
  placeBirth VARCHAR2(25 CHAR),
  passport VARCHAR2(30 CHAR),
  address VARCHAR2(50 CHAR),
  regAddress VARCHAR2(50 CHAR),
  maritalStat VARCHAR2(20 CHAR),
  children NUMBER(10,0),
  dateBirth VARCHAR2(50 CHAR)
);


PROMPT Creating Primary Key Constraint personalNum_pk on table personal_inf ... 
ALTER TABLE personal_inf
ADD CONSTRAINT personalNum_pk PRIMARY KEY
(
  personalNum
)
ENABLE
;

-- DROP TABLE official_inf CASCADE CONSTRAINTS;


PROMPT Creating Table official_inf ...
CREATE TABLE official_inf (
  idEmployee NUMBER(10,0) NOT NULL,
  personalNum NUMBER(10,0),
  surname VARCHAR2(50 CHAR),
  name VARCHAR2(50 CHAR),
  patronymic VARCHAR2(50 CHAR),
  idDep NUMBER(10,0),
  idPost NUMBER(10,0),
  education VARCHAR2(50 CHAR),
  idSpec NUMBER(10,0),
  experience VARCHAR2(50 CHAR),
  phoneNum VARCHAR2(20 CHAR),
  wage NUMBER(10,0),
  status VARCHAR2(20 CHAR)
);


PROMPT Creating Primary Key Constraint idEmployee_pk on table official_inf ... 
ALTER TABLE official_inf
ADD CONSTRAINT idEmployee_pk PRIMARY KEY
(
  idEmployee
)
ENABLE
;
PROMPT Creating Index IX_OINF on official_inf ...
CREATE INDEX IX_OINF ON official_inf
(
  idEmployee,
  idDep,
  idPost,
  wage
) 
;

-- DROP TABLE geometry_columns CASCADE CONSTRAINTS;

/*
PROMPT Creating Table geometry_columns ...
CREATE TABLE geometry_columns (
  f_table_catalog VARCHAR2(128 CHAR) NOT NULL,
  f_table_schema VARCHAR2(128 CHAR) NOT NULL,
  f_table_name VARCHAR2(256 CHAR) NOT NULL,
  f_geometry_column VARCHAR2(256 CHAR) NOT NULL,
  coord_dimension NUMBER(10,0) NOT NULL,
  srid NUMBER(10,0) NOT NULL,
  geometry_type VARCHAR2(30 CHAR) NOT NULL
);


PROMPT Creating Primary Key Constraint geometry_columns_pk on table geometry_columns ... 
ALTER TABLE geometry_columns
ADD CONSTRAINT geometry_columns_pk PRIMARY KEY
(
  f_table_catalog,
  f_table_schema,
  f_table_name,
  f_geometry_column
)
ENABLE
;

-- DROP TABLE spatial_ref_sys CASCADE CONSTRAINTS;


PROMPT Creating Table spatial_ref_sys ...
CREATE TABLE spatial_ref_sys (
  srid NUMBER(10,0) NOT NULL,
  auth_name VARCHAR2(256 CHAR),
  auth_srid NUMBER(10,0),
  srtext VARCHAR2(2048 CHAR),
  proj4text VARCHAR2(2048 CHAR)
);


PROMPT Creating Primary Key Constraint PK__spatial___36B11BD5A38D8E7F on table spatial_ref_sys ... 
ALTER TABLE spatial_ref_sys
ADD CONSTRAINT PK__spatial___36B11BD5A38D8E7F PRIMARY KEY
(
  srid
)
ENABLE
;

-- DROP TABLE gadm36_blr_2 CASCADE CONSTRAINTS;


PROMPT Creating Table gadm36_blr_2 ...
CREATE TABLE gadm36_blr_2 (
  ogr_fid NUMBER(10,0) NOT NULL,
  ogr_geometry geometry(0,0),
  gid_0 NVARCHAR2(80),
  name_0 NVARCHAR2(80),
  gid_1 NVARCHAR2(80),
  name_1 NVARCHAR2(80),
  nl_name_1 NVARCHAR2(80),
  gid_2 NVARCHAR2(80),
  name_2 NVARCHAR2(80),
  varname_2 NVARCHAR2(80),
  nl_name_2 NVARCHAR2(80),
  type_2 NVARCHAR2(80),
  engtype_2 NVARCHAR2(80),
  cc_2 NVARCHAR2(80),
  hasc_2 NVARCHAR2(80)
);


PROMPT Creating Primary Key Constraint PK_gadm36_blr_2 on table gadm36_blr_2 ... 
ALTER TABLE gadm36_blr_2
ADD CONSTRAINT PK_gadm36_blr_2 PRIMARY KEY
(
  ogr_fid
)
ENABLE
;
PROMPT Creating Index ogr_dbo_gadm36_blr_2_ogr_geome on gadm36_blr_2 ...
CREATE INDEX ogr_dbo_gadm36_blr_2_ogr_geome ON gadm36_blr_2
(
  ogr_geometry
) ;

connect dbo_PERSONNEL/dbo_PERSONNEL;
*/

CREATE OR REPLACE FORCE VIEW DEPARTMENT 
AS 
   SELECT department ,
          leader 
     FROM departments ;


CREATE OR REPLACE FORCE VIEW POST 
AS 
   SELECT idPost ,
          post 
     FROM posts ;


CREATE OR REPLACE FORCE VIEW SPEC 
AS 
   SELECT idSpec ,
          specialty 
     FROM specialty ;


CREATE OR REPLACE FORCE VIEW PINF 
AS 
   SELECT personalNum ,
          dateBirth ,
          ADDRESS ,
          maritalStat ,
          children 
     FROM personal_inf ;


CREATE OR REPLACE FORCE VIEW OINF 
AS 
   SELECT idEmployee ,
          surname ,
          NAME ,
          patronymic ,
          idDep ,
          idPost ,
          idSpec ,
          experience ,
          wage ,
          STATUS 
     FROM official_inf ;


CREATE OR REPLACE FORCE VIEW EMPLOYEE 
AS 
   SELECT idEmployee ,
          personalNum ,
          surname ,
          NAME ,
          patronymic ,
          idDep ,
          idPost ,
          education ,
          idSpec ,
          experience ,
          phoneNum ,
          wage ,
          STATUS 
     FROM official_inf 
     WHERE STATUS = 'W';


CREATE OR REPLACE PROCEDURE AddOfficial_inf--  

(
  v_idEmployee IN NUMBER DEFAULT NULL ,
  v_personalNum IN NUMBER DEFAULT NULL ,
  v_surname IN VARCHAR2 DEFAULT NULL ,
  v_name IN VARCHAR2 DEFAULT NULL ,
  v_patronymic IN VARCHAR2 DEFAULT NULL ,
  v_idDep IN NUMBER DEFAULT NULL ,
  v_idPost IN NUMBER DEFAULT NULL ,
  v_education IN VARCHAR2 DEFAULT NULL ,
  v_idSpec IN NUMBER DEFAULT NULL ,
  v_experience IN VARCHAR2 DEFAULT NULL ,
  v_phoneNum IN VARCHAR2 DEFAULT NULL ,
  v_wage IN NUMBER DEFAULT NULL ,
  v_status IN VARCHAR2 DEFAULT NULL 
)
AS

BEGIN

   INSERT INTO official_inf
     ( idEmployee, personalNum, surname, NAME, patronymic, idDep, idPost, education, idSpec, experience, phoneNum, wage, STATUS )
     VALUES ( v_idEmployee, v_personalNum, v_surname, v_name, v_patronymic, v_idDep, v_idPost, v_education, v_idSpec, v_experience, v_phoneNum, v_wage, v_status );
END;
/
CREATE OR REPLACE PROCEDURE AddPersonal_inf--   

(
  v_personalNum IN NUMBER DEFAULT NULL ,
  v_placeBirth IN VARCHAR2 DEFAULT NULL ,
  v_passport IN VARCHAR2 DEFAULT NULL ,
  v_address IN VARCHAR2 DEFAULT NULL ,
  v_regAddress IN VARCHAR2 DEFAULT NULL ,
  v_maritalStat IN VARCHAR2 DEFAULT NULL ,
  v_children IN NUMBER DEFAULT NULL ,
  v_dateBirth IN VARCHAR2 DEFAULT NULL 
)
AS

BEGIN

   INSERT INTO personal_inf
     ( personalNum, placeBirth, passport, ADDRESS, regAddress, maritalStat, children, dateBirth )
     VALUES ( v_personalNum, v_placeBirth, v_passport, v_address, v_regAddress, v_maritalStat, v_children, v_dateBirth );
END;
/

CREATE OR REPLACE FUNCTION avg_wage(v_idDep IN NUMBER)
RETURN FLOAT
is
v_avgw number;
BEGIN
   SELECT AVG(wage) INTO v_avgw FROM official_inf WHERE idDep = v_idDep;
   RETURN v_avgw;
END;

/
CREATE OR REPLACE PROCEDURE DeleteOINF
(
  v_idEmployee IN NUMBER DEFAULT NULL 
)
AS

BEGIN

   DELETE official_inf

     WHERE idEmployee = v_idEmployee;
END;
/
CREATE OR REPLACE PROCEDURE DeletePINF
(
  v_personalNum IN NUMBER DEFAULT NULL 
)
AS

BEGIN

   DELETE personal_inf

     WHERE personalNum = v_personalNum;
END;
/
CREATE OR REPLACE PROCEDURE GetEmployee
(
  cv_1 OUT SYS_REFCURSOR
)
AS

--    
BEGIN

   OPEN  cv_1 FOR
      SELECT * 
        FROM personal_inf 
               JOIN official_inf 
                ON personal_inf.personalNum = official_inf.personalNum ;
END;
/
CREATE OR REPLACE PROCEDURE GetEmployeeById--     

(
  v_personalNum IN NUMBER DEFAULT NULL ,
  cv_1 OUT SYS_REFCURSOR
)
AS

BEGIN

   OPEN  cv_1 FOR
      SELECT * 
        FROM personal_inf 
               JOIN official_inf 
                ON personal_inf.personalNum = official_inf.personalNum
        WHERE personal_inf.personalNum = v_personalNum ;
END;
/
drop PROCEDURE GetOffInf;
CREATE OR REPLACE PROCEDURE GetOffInf
(
  cv_1 OUT SYS_REFCURSOR
)
AS

BEGIN

   OPEN  cv_1 FOR
      SELECT * 
        FROM official_inf  ;
END;
/
CREATE OR REPLACE PROCEDURE GetPersInf
(
  cv_1 OUT SYS_REFCURSOR
)
AS

BEGIN

   OPEN  cv_1 FOR
      SELECT * 
        FROM personal_inf  ;
END;
/
CREATE OR REPLACE PROCEDURE ProcEmployee
(
  cv_1 OUT SYS_REFCURSOR
)
AS

-- 
BEGIN

   OPEN  cv_1 FOR
      SELECT * 
        FROM EMPLOYEE  ;
END;
/
CREATE OR REPLACE PROCEDURE UpdateOINF
(
  v_idEmployee IN NUMBER DEFAULT NULL ,
  v_personalNum IN NUMBER DEFAULT NULL ,
  v_surname IN VARCHAR2 DEFAULT NULL ,
  v_name IN VARCHAR2 DEFAULT NULL ,
  v_patronymic IN VARCHAR2 DEFAULT NULL ,
  v_idDep IN NUMBER DEFAULT NULL ,
  v_idPost IN NUMBER DEFAULT NULL ,
  v_education IN VARCHAR2 DEFAULT NULL ,
  v_idSpec IN NUMBER DEFAULT NULL ,
  v_experience IN VARCHAR2 DEFAULT NULL ,
  v_phoneNum IN VARCHAR2 DEFAULT NULL ,
  v_wage IN NUMBER DEFAULT NULL ,
  v_status IN VARCHAR2 DEFAULT NULL 
)
AS

BEGIN

   UPDATE official_inf
      SET idEmployee = v_idEmployee,
          personalNum = v_personalNum,
          surname = v_surname,
          NAME = v_name,
          patronymic = v_patronymic,
          idDep = v_idDep,
          idPost = v_idPost,
          education = v_education,
          idSpec = v_idSpec,
          experience = v_experience,
          phoneNum = v_phoneNum,
          wage = v_wage,
          STATUS = v_status
      WHERE idEmployee = v_idEmployee;
END;
/
CREATE OR REPLACE PROCEDURE UpdatePINF
(
  v_personalNum IN NUMBER DEFAULT NULL ,
  v_placeBirth IN VARCHAR2 DEFAULT NULL ,
  v_passport IN VARCHAR2 DEFAULT NULL ,
  v_address IN VARCHAR2 DEFAULT NULL ,
  v_regAddress IN VARCHAR2 DEFAULT NULL ,
  v_maritalStat IN VARCHAR2 DEFAULT NULL ,
  v_children IN NUMBER DEFAULT NULL ,
  v_dateBirth IN VARCHAR2 DEFAULT NULL 
)
AS

BEGIN

   UPDATE personal_inf
      SET personalNum = v_personalNum,
          placeBirth = v_placeBirth,
          passport = v_passport,
          ADDRESS = v_address,
          regAddress = v_regAddress,
          maritalStat = v_maritalStat,
          children = v_children,
          dateBirth = v_dateBirth
      WHERE personalNum = v_personalNum;
END;
/
CREATE OR REPLACE TRIGGER PINF_Trigger_up
   AFTER UPDATE
   ON personal_inf
   FOR EACH ROW

BEGIN
   DBMS_OUTPUT.PUT_LINE('Trigger after update personal_inf');
   RETURN;
END;
/

CREATE OR REPLACE TRIGGER OINF_Trigger_up
   AFTER UPDATE
   ON official_inf
   FOR EACH ROW

BEGIN
   DBMS_OUTPUT.PUT_LINE('Trigger after update official_inf');
   RETURN;
END;
/

connect dbo_PERSONNEL/dbo_PERSONNEL;

PROMPT Creating Foreign Key Constraint personalNum_FK on table personal_inf...
ALTER TABLE official_inf
ADD CONSTRAINT personalNum_FK FOREIGN KEY
(
  personalNum
)
REFERENCES personal_inf
(
  personalNum
)
ENABLE
;

PROMPT Creating Foreign Key Constraint idDep_ofInf_FK on table departments...
ALTER TABLE official_inf
ADD CONSTRAINT idDep_ofInf_FK FOREIGN KEY
(
  idDep
)
REFERENCES departments
(
  idDep
)
ENABLE
;

PROMPT Creating Foreign Key Constraint idPost_ofInf_FK on table posts...
ALTER TABLE official_inf
ADD CONSTRAINT idPost_ofInf_FK FOREIGN KEY
(
  idPost
)
REFERENCES posts
(
  idPost
)
ENABLE
;

PROMPT Creating Foreign Key Constraint idSpec_ofInf_FK on table specialty...
ALTER TABLE official_inf
ADD CONSTRAINT idSpec_ofInf_FK FOREIGN KEY
(
  idSpec
)
REFERENCES specialty
(
  idSpec
)
ENABLE
;

CREATE OR REPLACE TRIGGER departments_idDep_TRG BEFORE INSERT ON departments
FOR EACH ROW
DECLARE 
v_newVal NUMBER(12) := 0;
v_incval NUMBER(12) := 0;
BEGIN
  IF INSERTING AND :new.idDep IS NULL THEN
    SELECT  departments_idDep_SEQ.NEXTVAL INTO v_newVal FROM DUAL;
    -- If this is the first time this table have been inserted into (sequence == 1)
    IF v_newVal = 1 THEN 
      --get the max indentity value from the table
      SELECT NVL(max(idDep),0) INTO v_newVal FROM departments;
      v_newVal := v_newVal + 1;
      --set the sequence to that value
      LOOP
           EXIT WHEN v_incval>=v_newVal;
           SELECT departments_idDep_SEQ.nextval INTO v_incval FROM dual;
      END LOOP;
    END IF;
    -- save this to emulate @@identity
   utils.identity := v_newVal; 
   -- assign the value from the sequence to emulate the identity column
   :new.idDep := v_newVal;
  END IF;
END;

/

CREATE OR REPLACE TRIGGER posts_idPost_TRG BEFORE INSERT ON posts
FOR EACH ROW
DECLARE 
v_newVal NUMBER(12) := 0;
v_incval NUMBER(12) := 0;
BEGIN
  IF INSERTING AND :new.idPost IS NULL THEN
    SELECT  posts_idPost_SEQ.NEXTVAL INTO v_newVal FROM DUAL;
    -- If this is the first time this table have been inserted into (sequence == 1)
    IF v_newVal = 1 THEN 
      --get the max indentity value from the table
      SELECT NVL(max(idPost),0) INTO v_newVal FROM posts;
      v_newVal := v_newVal + 1;
      --set the sequence to that value
      LOOP
           EXIT WHEN v_incval>=v_newVal;
           SELECT posts_idPost_SEQ.nextval INTO v_incval FROM dual;
      END LOOP;
    END IF;
    -- save this to emulate @@identity
   utils.identity := v_newVal; 
   -- assign the value from the sequence to emulate the identity column
   :new.idPost := v_newVal;
  END IF;
END;

/

CREATE OR REPLACE TRIGGER specialty_idSpec_TRG BEFORE INSERT ON specialty
FOR EACH ROW
DECLARE 
v_newVal NUMBER(12) := 0;
v_incval NUMBER(12) := 0;
BEGIN
  IF INSERTING AND :new.idSpec IS NULL THEN
    SELECT  specialty_idSpec_SEQ.NEXTVAL INTO v_newVal FROM DUAL;
    -- If this is the first time this table have been inserted into (sequence == 1)
    IF v_newVal = 1 THEN 
      --get the max indentity value from the table
      SELECT NVL(max(idSpec),0) INTO v_newVal FROM specialty;
      v_newVal := v_newVal + 1;
      --set the sequence to that value
      LOOP
           EXIT WHEN v_incval>=v_newVal;
           SELECT specialty_idSpec_SEQ.nextval INTO v_incval FROM dual;
      END LOOP;
    END IF;
    -- save this to emulate @@identity
   utils.identity := v_newVal; 
   -- assign the value from the sequence to emulate the identity column
   :new.idSpec := v_newVal;
  END IF;
END;

/

CREATE OR REPLACE TRIGGER gadm36_blr_2_ogr_fid_TRG BEFORE INSERT ON gadm36_blr_2
FOR EACH ROW
DECLARE 
v_newVal NUMBER(12) := 0;
v_incval NUMBER(12) := 0;
BEGIN
  IF INSERTING AND :new.ogr_fid IS NULL THEN
    SELECT  gadm36_blr_2_ogr_fid_SEQ.NEXTVAL INTO v_newVal FROM DUAL;
    -- If this is the first time this table have been inserted into (sequence == 1)
    IF v_newVal = 1 THEN 
      --get the max indentity value from the table
      SELECT NVL(max(ogr_fid),0) INTO v_newVal FROM gadm36_blr_2;
      v_newVal := v_newVal + 1;
      --set the sequence to that value
      LOOP
           EXIT WHEN v_incval>=v_newVal;
           SELECT gadm36_blr_2_ogr_fid_SEQ.nextval INTO v_incval FROM dual;
      END LOOP;
    END IF;
    -- save this to emulate @@identity
   utils.identity := v_newVal; 
   -- assign the value from the sequence to emulate the identity column
   :new.ogr_fid := v_newVal;
  END IF;
END;

/

ALTER VIEW DEPARTMENT COMPILE;

ALTER VIEW POST COMPILE;

ALTER VIEW SPEC COMPILE;

ALTER VIEW PINF COMPILE;

ALTER VIEW OINF COMPILE;

ALTER VIEW EMPLOYEE COMPILE;

DISCONNECT;
